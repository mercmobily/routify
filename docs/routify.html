<!DOCTYPE html>


<html>
<head>
  <title>Routify&#39;s source code</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <link rel="stylesheet" media="all" href="public/stylesheets/normalize.css" />
  <link rel="stylesheet" media="all" href="tpe.css" />
</head>
<body>
  <div class="container">
      <div class="header">
        <div class="topbar">
          <div id="logo" alt="TPE">
          </div>
          <h3>Routify&#39;s source code</h3>
          <!-- <img id="logo" src="/images/TPE_logo_white.png" height="60px" alt="TPE" > -->
          <div class="links">
            <a href="https://github.com/mobily-enterprises/routify" target="_blank" title="View on GitHub">
              <svg role="img" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><title>GitHub icon</title><path d="M12 .297c-6.63 0-12 5.373-12 12 0 5.303 3.438 9.8 8.205 11.385.6.113.82-.258.82-.577 0-.285-.01-1.04-.015-2.04-3.338.724-4.042-1.61-4.042-1.61C4.422 18.07 3.633 17.7 3.633 17.7c-1.087-.744.084-.729.084-.729 1.205.084 1.838 1.236 1.838 1.236 1.07 1.835 2.809 1.305 3.495.998.108-.776.417-1.305.76-1.605-2.665-.3-5.466-1.332-5.466-5.93 0-1.31.465-2.38 1.235-3.22-.135-.303-.54-1.523.105-3.176 0 0 1.005-.322 3.3 1.23.96-.267 1.98-.399 3-.405 1.02.006 2.04.138 3 .405 2.28-1.552 3.285-1.23 3.285-1.23.645 1.653.24 2.873.12 3.176.765.84 1.23 1.91 1.23 3.22 0 4.61-2.805 5.625-5.475 5.92.42.36.81 1.096.81 2.22 0 1.606-.015 2.896-.015 3.286 0 .315.21.69.825.57C20.565 22.092 24 17.592 24 12.297c0-6.627-5.373-12-12-12"/></svg>
            </a>
          </div>
        </div>

      </div>
      <div class="main">
        
          <div class="toc">
            <ul>
              
                
                
                  <li>
                      <a class="source " href="index.html">
                          index
                      </a>
                  </li>
                
              
                
                
                  <li>
                      <a class="source " href="api.html">
                          api
                      </a>
                  </li>
                
              
                
                
                  <li>
                      <a class="source " href="guides.html">
                          guides
                      </a>
                  </li>
                
              
                
                
                  <li>
                      <a class="source  indented " href="guides/01-straight-html.html">
                          01 straight html
                      </a>
                  </li>
                
              
                
                
                  <li>
                      <a class="source  indented " href="guides/02-open-wc-to-routify.html">
                          02 open wc to routify
                      </a>
                  </li>
                
              
                
                
                  <li>
                      <a class="source  indented " href="guides/03-open-wc-page-with-parameter.html">
                          03 open wc page with parameter
                      </a>
                  </li>
                
              
                
                
                  <li>
                      <a class="source  indented " href="guides/04-open-wc-routing-groups.html">
                          04 open wc routing groups
                      </a>
                  </li>
                
              
                
                
                  <li>
                      <a class="source  current " href="routify.html">
                          routify.js
                      </a>
                  </li>
                
              
            </ul>
          </div>
        
        <div class="contentPage">
          
            
            <p>routify.js is an unintrusive module that deals with routing
In a nutshell, all routify.js does is set a specific attribute/property (<code>active</code>
by default) depending on whether an element satisfies a routing pattern
(e.g. ‘/view-jobs/:id’). It will also run a callback (‘routerCallback’) whenever
the routing matches, so that pages can do whatever they are supposed to do when
they become visible.</p>
<p>A page can match multiple paths. Also, paths can contain wild characters:</p>
<ul>
<li><code>/preferences/*/large</code> – will match <code>/preferences/user/large</code> and
<code>/preferences/company/large</code>. Basicaly, <code>*</code> will match one word anywhere in the path</li>
<li><code>/view/**</code> – will match <code>/view/one/two/three</code> and <code>/view/whatever</code>. Basically,
<code>**</code> will match anything regardless of what follows.</li>
</ul>
<p>A page will belong to a “routing group”.
Most applications will have one main routing group (e.g. <code>/likes</code>, <code>/account</code>, etc).
However, another group might be <code>/account/settings</code>, <code>/account/photo</code>, and so on.
Only one page at a time will be active in any given group.</p>
<h2 id="modules-variables">Module’s variables</h2>

            
          
            
            <p>These are the module’s global state.
<code>elements</code> is the list of observed elements; <code>routerInstalled</code> is a global
flag that signals that the global router was already installed. The router is
installed once, globally, when the first route is registered.</p>

            
              <div class='highlight'><pre><span class="hljs-keyword">const</span> elements = { }
<span class="hljs-keyword">let</span> routerInstalled = <span class="hljs-literal">false</span></pre></div>
            
          
            
            <h2 id="configuration-options-and-helpers">Configuration options and helpers</h2>

            
          
            
            <p>routify.js can be configured by the <code>setConfig</code> function, which will set
keys for the module variable <code>config</code>. The configuration defines
what attribute and property are used for:</p>
<ul>
<li><code>activeAttribute/activeProperty</code> – elements’ active flag</li>
<li><code>pagePathAttribute/pagePathProperty</code> – elements’ paths</li>
<li><code>routingGroupAttribute/routingGroupProperty</code> – elements’ routing groups</li>
</ul>
<p>Developers can redefine these by using the <code>setConfig()</code> function. For example,
developers can configure routify so that the attribute <code>activated</code> is
added to a matching element like this:</p>
<pre><code>setConfig(<span class="hljs-string">'activeAttribute'</span>, <span class="hljs-string">'activated'</span>)</code></pre>
            
              <div class='highlight'><pre><span class="hljs-keyword">const</span> config = {
  <span class="hljs-attr">activeAttribute</span>: <span class="hljs-string">'active'</span>,
  <span class="hljs-attr">activeProperty</span>: <span class="hljs-string">'active'</span>,
  <span class="hljs-attr">pagePathAttribute</span>: <span class="hljs-string">'page-path'</span>,
  <span class="hljs-attr">pagePathProperty</span>: <span class="hljs-string">'pagePath'</span>,
  <span class="hljs-attr">routingGroupAttribute</span>: <span class="hljs-string">'routing-group'</span>,
  <span class="hljs-attr">routingGroupProperty</span>: <span class="hljs-string">'routingGroup'</span>
}
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> setConfig = <span class="hljs-function">(<span class="hljs-params">key, value</span>) =&gt;</span> { config[key] = value }</pre></div>
            
          
            
            <p>An element can be configured for routify.js in several different ways: via
attributes (to the HTML element), properties or constructors’ properties.
For example the path an element will depend on for activation can be specified
using:</p>
<ul>
<li>The attribute <code>page-path</code><pre><code>&lt;page-about <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">"page"</span> page-path=<span class="hljs-string">"/page-about"</span>&gt;...&lt;<span class="hljs-regexp">/page-about&gt;</span></code></pre></li>
<li>The property <code>pagePath</code><pre><code>&lt;page-about id="about" class="page"&gt;...&lt;/page-about&gt;
&lt;script&gt;window.querySelector('#about').pagePath = "/page-about"</code></pre></li>
<li>The property <code>pagePath</code> in the element’s constructor. Useful for ES6’s
class definitions:<pre><code><span class="hljs-keyword">static</span> <span class="hljs-keyword">get</span> pagePath () { <span class="hljs-keyword">return</span> <span class="hljs-string">'/page-one/:id'</span> }</code></pre></li>
</ul>
<p>The following functions are helper functions to facilitate the fetching
of the configuration options wherever they are, returning sane defaults,
for the attributes/properties <code>active</code>, <code>page-path/pagePath</code> and
<code>routing-group/routingGroup</code></p>

            
              <div class='highlight'><pre><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getPagePathFromEl</span> (<span class="hljs-params">el</span>) </span>{
  <span class="hljs-keyword">const</span> toArray = <span class="hljs-function"><span class="hljs-params">p</span> =&gt;</span> {
    <span class="hljs-keyword">return</span> (!p || !(p.indexOf(<span class="hljs-string">' '</span>) &gt;= <span class="hljs-number">0</span>))
      ? p
      : p.split(<span class="hljs-string">' '</span>)
  }

  <span class="hljs-keyword">return</span> toArray(el.getAttribute(config.pagePathAttribute)) ||
         el[config.pagePathProperty] ||
         el.constructor[config.pagePathProperty] ||
         <span class="hljs-literal">false</span>
}

<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getRoutingGroupFromEl</span> (<span class="hljs-params">el</span>) </span>{
  <span class="hljs-keyword">return</span> el.getAttribute(config.routingGroupAttribute) ||
         el[config.routingGroupProperty] ||
         el.constructor[config.routingGroupProperty] ||
         <span class="hljs-string">'default'</span>
}

<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getActiveFromEl</span> (<span class="hljs-params">el</span>) </span>{
  <span class="hljs-keyword">return</span> el.hasAttribute(config.activeAttribute) ||
         el[config.activeProperty] ||
         <span class="hljs-literal">false</span>
}</pre></div>
            
          
            
            <h3 id="registering-routes">Registering routes</h3>

            
          
            
            <p>The heart of routify.js is the <code>registerRoute()</code> function, which will
turn an HTML element in the page into a location-aware element that will
activate itself when the browser’s path matches the element’s path template.</p>
<p>This function has two very distinct parts; in the first part, a global router
function is installed if it weren’t already installed. You can see this as a
once-only, on the spot operation to make sure that clicks are intercepted
globally. In the second part, the element is actually registered as it’s added to
the <code>elements</code> global variable and it’s “maybe” activated (it depends on whether
the app location does satisfy the route).</p>
<p>The attempted activation is important: it means that registering all routes
automatically means that the matching ones will be activated.</p>

            
              <div class='highlight'><pre><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">registerRoute</span> (<span class="hljs-params">el</span>) </span>{
  <span class="hljs-keyword">const</span> group = getRoutingGroupFromEl(el)

  <span class="hljs-comment">/* Create the element group if it doesn't exist already */</span>
  <span class="hljs-keyword">if</span> (!elements[group]) elements[group] = { <span class="hljs-attr">list</span>: [], <span class="hljs-attr">activeElement</span>: <span class="hljs-literal">null</span> }

  <span class="hljs-comment">/* Install the GLOBAL router -- if it's not already installed */</span>
  <span class="hljs-keyword">if</span> (!routerInstalled) {
    installRouter(<span class="hljs-function">(<span class="hljs-params">location, e</span>) =&gt;</span> {
      activateCurrentPath(e)
    })
    routerInstalled = <span class="hljs-literal">true</span>
  }

  <span class="hljs-comment">/* Register element, checking that it's not already registered */</span>
  <span class="hljs-keyword">if</span> (el.__routingRegistered) {
    <span class="hljs-built_in">console</span>.error(<span class="hljs-string">'WARNING. Element has registered twice for routing:'</span>, el.tagName)
  }
  el.__routingRegistered = <span class="hljs-literal">true</span>

  <span class="hljs-comment">/* Push the element to the list of elements in this group */</span>
  elements[group].list.push(el)

  <span class="hljs-comment">/* MAYBE activate the element. */</span>
  maybeActivateElement(el, <span class="hljs-literal">null</span>)
}</pre></div>
            
          
            
            <p>Simple apps might just have small amounts of javascript sprinkled around.
They can use <code>registerRoutesFromSelector()</code> to register all elements
matching a selector.</p>

            
              <div class='highlight'><pre><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">registerRoutesFromSelector</span> (<span class="hljs-params">root, selector</span>) </span>{
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> el <span class="hljs-keyword">of</span> root.querySelectorAll(selector)) {
    <span class="hljs-keyword">const</span> group = getRoutingGroupFromEl(el)
    <span class="hljs-keyword">if</span> (!elements[group]) elements[group] = { <span class="hljs-attr">list</span>: [], <span class="hljs-attr">activeElement</span>: <span class="hljs-literal">null</span> }
    <span class="hljs-keyword">if</span> (!elements[group].list.find(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item === el)) registerRoute(el)
  }
}</pre></div>
            
          
            
            <p><code>activateCurrentPath()</code> will run <code>maybeActivateElement()</code>
for each routing element in each group.
The function above <code>registerRoute()</code> will call this function
every time there is a mouse click on a link. This will ensure
that the right element is active in each group – in other words, it will
ensure that the right pages are shown.</p>

            
              <div class='highlight'><pre><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> activateCurrentPath = <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> {
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> group <span class="hljs-keyword">of</span> <span class="hljs-built_in">Object</span>.keys(elements)) {
    <span class="hljs-keyword">const</span> list = elements[group].list
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> el <span class="hljs-keyword">of</span> list) {
      maybeActivateElement(el, e)
    }
  }
}</pre></div>
            
          
            
            <h3 id="maybeactivateelement">maybeActivateElement()</h3>

            
          
            
            <p><code>maybeActivateElement()</code> will check whether the browser’s location matches
the element’s location pattern. If it does, it will set the activate
attribute/property as true. The check is done using the <code>locationMatch()</code>
function explained later.</p>

            
              <div class='highlight'><pre><span class="hljs-keyword">const</span> maybeActivateElement = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">el, e</span>) </span>{
  <span class="hljs-keyword">const</span> path = getPagePathFromEl(el)
  <span class="hljs-keyword">const</span> group = getRoutingGroupFromEl(el)

  <span class="hljs-comment">/* No path, no setting nor unsetting of `active` */</span>
  <span class="hljs-keyword">if</span> (!path) {
    <span class="hljs-built_in">console</span>.error(<span class="hljs-string">'Routing element does not have a path:'</span>, el)
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
  }</pre></div>
            
          
            
            <p>The first step is checking whether the element’s path matches the
window’s path. If it doesn’t, there is nothing to do.</p>

            
              <div class='highlight'><pre>  <span class="hljs-keyword">const</span> locationMatchedParams = locationMatch(path)
  <span class="hljs-keyword">if</span> (!locationMatchedParams) <span class="hljs-keyword">return</span>
  <span class="hljs-keyword">debugger</span></pre></div>
            
          
            
            <p>Matching a path is not enough. Keep in mind that <code>activateCurrentPath()</code>
will go through <em>every</em> element in the group. So, while <code>/account</code> might well
be a match, <code>/**</code> (likely to be the “File not found” page) will also be
a match – therefore the “Not found” one will always win.
Also, the “Not found” element will always win when elements are being registered
if it’s the last one in the DOM. For this reason, it’s crucial to check if
swapping is “allowed”.</p>
<p>The <code>allowSwappingActiveElementWith()</code> function does exactly this: it
checks whether <code>el</code>, which was matched with the path <code>__PATH__</code> (from <code>locationMatch()</code>),
is more specific than the currently active element. If it is, it
will be swapped. If it’s not, <code>maybeActivateElement()</code> won’t activate it.</p>
<p>In other words, <code>maybeActivateElement()</code> will only activate an element
if it’s more specific than the element currently active.
Again, since an element might have multuple paths, it’s important to store
the path that actually matched when the element was active</p>

            
              <div class='highlight'><pre>  <span class="hljs-keyword">if</span> (allowSwappingActiveElementWith(el, locationMatchedParams.__PATH__)) {
    <span class="hljs-keyword">const</span> oldActiveElement = elements[group].activeElement

    <span class="hljs-comment">/* The same element is being activated again: just update the */</span>
    <span class="hljs-comment">/* aactivating path (which may have changed) and run the routingCallback */</span>
    <span class="hljs-keyword">if</span> (el === oldActiveElement) {
      elements[group].activeElementWithPath = locationMatchedParams.__PATH__
      callRouterCallback(el, locationMatchedParams, e)

    <span class="hljs-comment">/* The active element has changed: mark the old one as inactive, make the new */</span>
    <span class="hljs-comment">/* element as active, and run the router callback */</span>
    <span class="hljs-comment">/* Note that routify NEEDS to know the path that made the element match */</span>
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">if</span> (oldActiveElement) toggleElementActive(oldActiveElement, <span class="hljs-literal">false</span>)
      toggleElementActive(el, <span class="hljs-literal">true</span>)
      elements[group].activeElement = el
      elements[group].activeElementWithPath = locationMatchedParams.__PATH__

      callRouterCallback(el, locationMatchedParams, e)
    }
    <span class="hljs-comment">/* Return true or false, depending on the element being active or not */</span>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>
  }
  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
}</pre></div>
            
          
            
            <p>This is the implementation of <code>allowSwappingActiveElementWith()</code>.
Keep in mind that a page might have multiple paths. However, in this context,
routify will compare:</p>
<ul>
<li>the specificity of the path that actually matched the
element (returned by <code>locationMatch()</code> as <code>locationMatchedParams.__PATH__</code>)</li>
<li>with the specificity of the path matched in the currently active element
(in <code>elements[group].activeElementWithPath</code>).</li>
</ul>

            
              <div class='highlight'><pre><span class="hljs-keyword">const</span> allowSwappingActiveElementWith = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">el, elPath</span>) </span>{</pre></div>
            
          
            
            <p>No current element: definitely allow</p>

            
              <div class='highlight'><pre>  <span class="hljs-keyword">const</span> group = getRoutingGroupFromEl(el)
  <span class="hljs-keyword">const</span> oldActiveElement = elements[group].activeElement
  <span class="hljs-keyword">if</span> (!oldActiveElement) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span></pre></div>
            
          
            
            <p>Current active element doesn’t match the location: definitely allow</p>

            
              <div class='highlight'><pre>  <span class="hljs-keyword">const</span> oldActiveElementPath = elements[group].activeElementWithPath
  <span class="hljs-keyword">if</span> (!locationMatch(oldActiveElementPath)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span></pre></div>
            
          
            
            <p>The currently active element is MORE specific: do NOT allow</p>

            
              <div class='highlight'><pre>  <span class="hljs-keyword">if</span> (compareSpecificity(oldActiveElementPath, elPath) === <span class="hljs-number">1</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
  }</pre></div>
            
          
            
            <p>Otherwise, return true</p>

            
              <div class='highlight'><pre>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>
}</pre></div>
            
          
            
            <p>The function to compare specificity is really simple: it will take
the paths <code>a</code> and <code>b</code> and:</p>
<ul>
<li>return 1 if <code>a</code> wins</li>
<li>return -1 if <code>b</code> wins</li>
<li>return 0  if it is a draw</li>
</ul>

            
              <div class='highlight'><pre><span class="hljs-keyword">const</span> compareSpecificity = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">a, b</span>) </span>{
  <span class="hljs-keyword">const</span> firstCharacterSpecial = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">str</span>) </span>{
    <span class="hljs-keyword">const</span> c = str.charAt(<span class="hljs-number">0</span>)
    <span class="hljs-keyword">return</span> c === <span class="hljs-string">':'</span> || c === <span class="hljs-string">'*'</span>
  }

  <span class="hljs-keyword">const</span> aObject = <span class="hljs-keyword">new</span> URL(a, <span class="hljs-string">'http://localhost/'</span>)
  <span class="hljs-keyword">const</span> aTokens = aObject.pathname.split(<span class="hljs-string">'/'</span>)

  <span class="hljs-keyword">const</span> bObject = <span class="hljs-keyword">new</span> URL(b, <span class="hljs-string">'http://localhost/'</span>)
  <span class="hljs-keyword">const</span> bTokens = bObject.pathname.split(<span class="hljs-string">'/'</span>)

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">Math</span>.max(a.length, b.length); i++) {
    <span class="hljs-keyword">const</span> aToken = aTokens[i]
    <span class="hljs-keyword">const</span> bToken = bTokens[i]

    <span class="hljs-comment">/* Tokens are the same: next */</span>
    <span class="hljs-keyword">if</span> (aToken === bToken) <span class="hljs-keyword">continue</span>

    <span class="hljs-comment">/* Whichever is longer wins */</span>
    <span class="hljs-keyword">if</span> (aToken &amp;&amp; <span class="hljs-keyword">typeof</span> bToken === <span class="hljs-string">'undefined'</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>
    <span class="hljs-keyword">if</span> (bToken &amp;&amp; <span class="hljs-keyword">typeof</span> aToken === <span class="hljs-string">'undefined'</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>

    <span class="hljs-comment">/* They both start with non-special characters: next */</span>
    <span class="hljs-keyword">if</span> (!firstCharacterSpecial(aToken) &amp;&amp; !firstCharacterSpecial(bToken)) <span class="hljs-keyword">continue</span>

    <span class="hljs-comment">/* Whichever has ** loses since it's really not specific */</span>
    <span class="hljs-keyword">if</span> (aToken === <span class="hljs-string">'**'</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>
    <span class="hljs-keyword">if</span> (bToken === <span class="hljs-string">'**'</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>

    <span class="hljs-comment">/* Whichever has * loses */</span>
    <span class="hljs-keyword">if</span> (aToken === <span class="hljs-string">'*'</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>
    <span class="hljs-keyword">if</span> (bToken === <span class="hljs-string">'*'</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>
  }
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>
}</pre></div>
            
          
            
            <p>Sometimes it’s necessary for a program to force the activation
of a route, even if it doesn’t match a path.
This is what this function is for
In a real-world scenario, an SAP that loads modules dynamically can’t
have a “catch-all” <code>/**</code> as a fallback, since it will flash as active
while the actual module is loaded. In this case, developers will have to
avoid defining a catch-all callback, and activate the “Not found” page
by hand</p>

            
              <div class='highlight'><pre><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> activateElement = <span class="hljs-function">(<span class="hljs-params">elementToActivate, path = <span class="hljs-string">''</span></span>) =&gt;</span> {
  <span class="hljs-keyword">const</span> group = getRoutingGroupFromEl(elementToActivate)

  <span class="hljs-keyword">const</span> list = elements[group].list

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> el <span class="hljs-keyword">of</span> list) {
    <span class="hljs-comment">/* If it's not the element to activate, pass */</span>
    <span class="hljs-keyword">if</span> (el !== elementToActivate) {
      toggleElementActive(el, <span class="hljs-literal">false</span>)

    <span class="hljs-comment">/* If it's the element to activate, do so */</span>
    <span class="hljs-comment">/* Note that the matching path is also stored if it's passed*/</span>
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">if</span> (!getActiveFromEl(el)) {
        toggleElementActive(el, <span class="hljs-literal">true</span>)
        elements[group].activeElement = el
        elements[group].activeElementWithPath = path
      }
      <span class="hljs-comment">/* Call the element's callback if set. Note that the 'path' */</span>
      <span class="hljs-comment">/* can well be null */</span>
      <span class="hljs-keyword">const</span> locationParams = locationMatch(path) || {}
      callRouterCallback(el, locationParams)
    }
  }
}</pre></div>
            
          
            
            <p>This is a utility function to call preRouterCallback, routerCallback
and  postRouterCallback</p>

            
              <div class='highlight'><pre><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">callRouterCallback</span> (<span class="hljs-params">el, locationParams, e</span>) </span>{
  <span class="hljs-keyword">if</span> (el.preRouterCallback) <span class="hljs-keyword">await</span> el.preRouterCallback(locationParams, e)
  <span class="hljs-keyword">if</span> (el.routerCallback) <span class="hljs-keyword">await</span> el.routerCallback(locationParams, e)
  <span class="hljs-keyword">if</span> (el.postRouterCallback) <span class="hljs-keyword">await</span> el.postRouterCallback(locationParams, e)
}</pre></div>
            
          
            
            <p>This is a simple helper that will toggle the <code>active</code>
attribute and property, and will emit a route-activated event if
the route was activated</p>

            
              <div class='highlight'><pre><span class="hljs-keyword">const</span> toggleElementActive = <span class="hljs-function">(<span class="hljs-params">el, active</span>) =&gt;</span> {
  el[config.activeProperty] = active
  el.toggleAttribute(config.activeAttribute, active)
  <span class="hljs-keyword">if</span> (active) el.dispatchEvent(<span class="hljs-keyword">new</span> CustomEvent(<span class="hljs-string">'route-activated'</span>, { <span class="hljs-attr">details</span>: { <span class="hljs-attr">element</span>: el }, <span class="hljs-attr">bubbles</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">composed</span>: <span class="hljs-literal">true</span> }))
}</pre></div>
            
          
            
            <p>This function is <em>extremely</em> inspired by the <code>installRouter</code> function found
in the <a href="https://www.npmjs.com/package/pwa-helpers">pwa-helpers</a> package by
the Polymer team.
It’s the original source but linted, reformatted from typescript, and fully commented.</p>
<p>The main aim of installRouter is to define a callback that will be called
every time the URL changes. This is achieved by listening to the <code>click</code> event:
when a “normal” link is clicked, <code>preventDefault()</code> is called and the location
is artificially added to the browser’s history with a pushState call.</p>

            
              <div class='highlight'><pre><span class="hljs-keyword">const</span> installRouter = <span class="hljs-function">(<span class="hljs-params">locationUpdatedCallback</span>) =&gt;</span> {
  <span class="hljs-comment">/* Listen for the click event */</span>
  <span class="hljs-built_in">document</span>.body.addEventListener(<span class="hljs-string">'click'</span>, e =&gt; {
    <span class="hljs-keyword">if</span> (e.defaultPrevented || e.button !== <span class="hljs-number">0</span> || e.metaKey || e.ctrlKey || e.shiftKey) <span class="hljs-keyword">return</span>

    <span class="hljs-comment">/* Check that the clicked element is indeed a "pure" link (no */</span>
    <span class="hljs-comment">/* 'download' or rel=external attribute */</span>
    <span class="hljs-keyword">const</span> anchor = e.composedPath().filter(<span class="hljs-function"><span class="hljs-params">n</span> =&gt;</span> n.tagName === <span class="hljs-string">'A'</span>)[<span class="hljs-number">0</span>]
    <span class="hljs-keyword">if</span> (!anchor || anchor.target || anchor.hasAttribute(<span class="hljs-string">'download'</span>) || anchor.getAttribute(<span class="hljs-string">'rel'</span>) === <span class="hljs-string">'external'</span>) <span class="hljs-keyword">return</span>

    <span class="hljs-comment">/* Check that it does have href, and it's not a mailto: link */</span>
    <span class="hljs-keyword">const</span> href = anchor.href
    <span class="hljs-keyword">if</span> (!href || href.indexOf(<span class="hljs-string">'mailto:'</span>) !== <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span>

    <span class="hljs-comment">/* Check that it's a local link */</span>
    <span class="hljs-keyword">const</span> location = <span class="hljs-built_in">window</span>.location
    <span class="hljs-keyword">const</span> origin = location.origin || location.protocol + <span class="hljs-string">'//'</span> + location.host
    <span class="hljs-keyword">if</span> (href.indexOf(origin) !== <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>

    <span class="hljs-comment">/* We are in business: prevent the browser from leaving the page, */</span>
    <span class="hljs-comment">/* and -- if the link has changed -- push the new location to the */</span>
    <span class="hljs-comment">/* browser's history */</span>
    e.preventDefault()
    <span class="hljs-keyword">if</span> (href !== location.href) {
      <span class="hljs-keyword">const</span> state = { <span class="hljs-attr">artificial</span>: <span class="hljs-literal">true</span> }

      <span class="hljs-built_in">window</span>.history.pushState(state, <span class="hljs-string">''</span>, href)

      <span class="hljs-comment">/* If a link was pressed, then the history has changed and */</span>
      <span class="hljs-comment">/* a popstate event should be called */</span>
      <span class="hljs-comment">/* The `artificial` property in the state will potentially tell */</span>
      <span class="hljs-comment">/* listeners that this wasn't a proper "pure" browser event (that is, */</span>
      <span class="hljs-comment">/* it wasn't the result of a user clicking on a button) */</span>
      emitPopstate({ state })
    }
  })

  <span class="hljs-comment">/* Make sure the passed callback is called when the history changes. The */</span>
  <span class="hljs-comment">/* emitPopState call above will trigger this */</span>
  <span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">'popstate'</span>, e =&gt; locationUpdatedCallback(<span class="hljs-built_in">window</span>.location, e))

  <span class="hljs-comment">/* Artificially call the callback at installation time. This is important so that */</span>
  <span class="hljs-comment">/* developers using this function can do one-off setups  */</span></pre></div>
            
          
            
            <p>locationUpdatedCallback(window.location, null)</p>

            
              <div class='highlight'><pre>}</pre></div>
            
          
            
            <p>The <code>installRouter()</code> function makes sure that the correct callback is called
whenever a user clicks on a link.</p>
<p>Changing the location programmatically with <code>window.history.pushState()</code> or
<code>window.history.replaceState()</code> won’t trigger the update callback – which
means that routing won’t respond.
In order to change location programmatically, after <code>pushState()</code> or <code>replaceState()</code>
an SPA using routify.js will need to manually emit a <code>popstate</code>
event. This function does just that:</p>

            
              <div class='highlight'><pre><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">emitPopstate</span> (<span class="hljs-params">state</span>) </span>{
  <span class="hljs-keyword">let</span> e
  <span class="hljs-keyword">if</span> (state) e = <span class="hljs-keyword">new</span> PopStateEvent(<span class="hljs-string">'popstate'</span>, state)
  <span class="hljs-keyword">else</span> e = <span class="hljs-keyword">new</span> PopStateEvent(<span class="hljs-string">'popstate'</span>)
  <span class="hljs-built_in">window</span>.dispatchEvent(e)
}</pre></div>
            
          
            
            <p>Finally, a route can un unregistered. These functions are provided for
completeness, as their use will be very much edge cases</p>

            
              <div class='highlight'><pre><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">unregisterRoute</span> (<span class="hljs-params">el</span>) </span>{
  <span class="hljs-keyword">const</span> group = getRoutingGroupFromEl(el)

  <span class="hljs-keyword">if</span> (!elements[group]) <span class="hljs-keyword">return</span>

  elements[group].list = elements[group].list.filter(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item !== el)
}

<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">unregisterRoutesFromSelector</span> (<span class="hljs-params">root, selector</span>) </span>{
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> el <span class="hljs-keyword">of</span> root.querySelectorAll(selector)) {
    <span class="hljs-keyword">const</span> group = getRoutingGroupFromEl(el)
    <span class="hljs-keyword">if</span> (!elements[group]) <span class="hljs-keyword">return</span>
    unregisterRoute(el)
  }
}</pre></div>
            
          
            
            <h3 id="location-matching">Location matching</h3>

            
          
            
            <p>This is a simple function that will check if a template URL matches with
<code>window.location</code>.</p>
<p>It’s very basic, and it might eventually be replaced with something more
complex (although client-side routing doesn’t tend to need complex
routing paths)</p>
<p>The allowed syntax is:</p>
<ul>
<li><code>/something</code></li>
<li><code>/something/:page</code></li>
<li><code>/something/whatever/:page</code></li>
<li><code>/something/*</code></li>
<li><code>/something/:page/*</code></li>
<li><code>/something/**</code></li>
</ul>
<p>Both <code>*</code> and <code>:</code> character will match anything (as long as it’s not empty).
The main difference is what the function returns: for <code>:</code> routes, if there is
a match, <code>locationMatch</code> will return an object where every key is the matching
<code>:key</code>. For example if the location is <code>/record/10</code> and the template is
<code>/record/:id</code>, this function will return <code>{ id: 10 }</code></p>
<p>Also, <code>**</code> should be at the end of a URL, to match “anything that follows”</p>

            
              <div class='highlight'><pre><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">locationMatch</span> (<span class="hljs-params">templateUrl, checker</span>) </span>{
  <span class="hljs-keyword">if</span> (!templateUrl) <span class="hljs-keyword">return</span>
  <span class="hljs-keyword">const</span> locationMatchExecutor = <span class="hljs-function">(<span class="hljs-params">templateUrl, checker</span>) =&gt;</span> {</pre></div>
            
          
            
            <p>Prepare the basic variables</p>

            
              <div class='highlight'><pre>    <span class="hljs-keyword">const</span> templateUrlObject = <span class="hljs-keyword">new</span> URL(templateUrl, <span class="hljs-string">'http://localhost/'</span>)
    <span class="hljs-keyword">const</span> templatePath = templateUrlObject.pathname.split(<span class="hljs-string">'/'</span>)
    <span class="hljs-keyword">const</span> browserUrlObject = <span class="hljs-built_in">window</span>.location
    <span class="hljs-keyword">const</span> browserPath = browserUrlObject.pathname.split(<span class="hljs-string">'/'</span>)

    <span class="hljs-keyword">if</span> (templatePath.length !== browserPath.length) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span></pre></div>
            
          
            
            <p>Check the hash – if present or marked as “must be empty”</p>

            
              <div class='highlight'><pre>    <span class="hljs-keyword">const</span> templateHash = (templateUrlObject.hash || <span class="hljs-string">'#'</span>).substr(<span class="hljs-number">1</span>)
    <span class="hljs-keyword">const</span> browserHash = (browserUrlObject.hash || <span class="hljs-string">'#'</span>).substr(<span class="hljs-number">1</span>)
    <span class="hljs-keyword">const</span> templateHashEmpty = templateUrl.endsWith(<span class="hljs-string">'#'</span>)
    <span class="hljs-keyword">let</span> hashMatching = <span class="hljs-literal">true</span>
    <span class="hljs-keyword">if</span> (templateHash || templateHashEmpty) {
      <span class="hljs-keyword">if</span> (templateHashEmpty &amp;&amp; browserHash) hashMatching = <span class="hljs-literal">false</span>
      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (templateHash === <span class="hljs-string">'*'</span> &amp;&amp; browserHash) hashMatching = <span class="hljs-literal">true</span>
      <span class="hljs-keyword">else</span> hashMatching = templateHash === browserHash
    }
    <span class="hljs-keyword">if</span> (!hashMatching) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span></pre></div>
            
          
            
            <p>Check the callbacks</p>

            
              <div class='highlight'><pre>    <span class="hljs-keyword">const</span> callbackParams = {}
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, l = templatePath.length; i &lt; l; i++) {
      <span class="hljs-keyword">if</span> (templatePath[i].startsWith(<span class="hljs-string">':'</span>)) {
        callbackParams[templatePath[i].substr(<span class="hljs-number">1</span>)] = browserPath[i]
      } <span class="hljs-keyword">else</span> {</pre></div>
            
          
            
            <p>If the template accepts anything, and the browser has something,
skip the next check</p>

            
              <div class='highlight'><pre>        <span class="hljs-keyword">if</span> (templatePath[i] === <span class="hljs-string">'*'</span> &amp;&amp; browserPath[i]) <span class="hljs-keyword">continue</span>

        <span class="hljs-keyword">if</span> (templatePath[i] === <span class="hljs-string">'**'</span>) <span class="hljs-keyword">break</span>

        <span class="hljs-keyword">if</span> (templatePath[i] !== browserPath[i]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
      }
    }
    callbackParams.__PATH__ = templateUrl</pre></div>
            
          
            
            <p>No param checker: return true, since parameters won’t need checking</p>

            
              <div class='highlight'><pre>    <span class="hljs-keyword">if</span> (!checker) <span class="hljs-keyword">return</span> callbackParams</pre></div>
            
          
            
            <p>Checker is there: if it passes, return the found params. Otherwise, fail</p>

            
              <div class='highlight'><pre>    <span class="hljs-keyword">if</span> (checker(callbackParams)) <span class="hljs-keyword">return</span> callbackParams
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
  }

  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">Array</span>.isArray(templateUrl)) <span class="hljs-keyword">return</span> locationMatchExecutor(templateUrl, checker)
  <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> templateUrlElement <span class="hljs-keyword">of</span> templateUrl) {
      <span class="hljs-keyword">const</span> r = locationMatchExecutor(templateUrlElement, checker)
      <span class="hljs-keyword">if</span> (r) <span class="hljs-keyword">return</span> r
    }
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
  }
}</pre></div>
            
          
        </div>
      </div>
    </div>
    <div class="bottombar">

    </div>
  </div>
</body>
</html>
